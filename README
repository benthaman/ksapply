backport-mode.sh
	Contains a set of shell functions to assist in generating a patch
	series from upstream commits.
	Useful when porting a list of commits from upstream to our kernel.
armor_origin.sh
	Transform a "Git-commit" tag into a "(cherry picked from ...)" line.
	Useful before importing patches into kernel.git.
clean_header.sh
	Filter a patch file such that it is properly formatted per SUSE rules.
	Useful before importing patches.
ksapply.sh
	Apply the next patch in the quilt queue while cleaning and renaming it.
	Useful when importing patches into kernel-source.git.
rename_patch.sh
	Move a patch file such that its new name is similar to what git
	format-patch would have picked.
	Useful when importing patches from a maildir.
check_missing_fixes.sh
	Check if a commit is referenced in the log of later commits.
	Useful to identify missing followup commits.
refs_in_series.sh
	Check if a commit is already part of a branch in kernel-source.git
	Useful to check if a list of commits have already been backported to
	our kernel.
series_sort.py
	Script to sort series.conf lines according to the upstream order of
	commits that the patches backport.
	This script requires git-sort from the git-helpers repository
	(https://github.com/benthaman/git-helpers).
	After cloning the current repository, run
		git submodule init
		git submodule update
	A convenient way to use series_sort.py to filter a subset of lines
	within series.conf when using the vim text editor is to visually
	select the lines and filter them through the script:
		shift-v
		j j j j [...] # or ctrl-d or /pattern<enter>
		:'<,'>! ~/<path>/series_sort.py
quilt-mode.sh
	Contains a set of shell functions to assist in backporting upstream
	commits to kernel-source.git.
	These functions are meant to be used with a modified `quilt` that can
	use series.conf directly instead of a shadow copy.
	(ssh://wotan.suse.de/~bpoirier/Export/quilt.git)
	These functions also rely on `git sort`, available from the above
	"git-helpers" repository.

+ Example workflow using kernel-source.git
Refer to the section "Generate the list of commit ids to backport" to generate
the primary list of commits to backport, /tmp/list

Generate the work tree with patches applied up to the first patch in the
"SLE12-SP3 network driver updates" section:
kernel-source$ ./scripts/sequence-patch.sh patches.drivers/mvneta-consolidate-autoneg-enabling.patch

It preferable to check that the driver builds before getting started:
kernel-source/tmp/current$ make -j4 drivers/net/ethernet/intel/e1000/

Import the quilt-mode functions:
kernel-source/tmp/current$ . ~/programming/suse/ksapply/quilt-mode.sh

Note that `q` is an alias for `quilt`. You may be using `q` a lot...

Set the list of commits to backport:
kernel-source/tmp/current$ qadd -r "bsc#1024371 FATE#321245" -d patches.drivers < /tmp/list4
Note that the commits are automatically sorted using git-sort.
The references and destination are saved in environment variables and reused
later by `qcp` (see below). They can also be specified directly to `qcp`.

The working list can be queried at any time. Note that it is kept in the
$series environment variable, so it will be lost if the shell exits and is not
available in other terminals.
kernel-source/tmp/current$ qnext
847a1d6796c7 e1000: Do not overestimate descriptor counts in Tx pre-check (v4.6-rc3)
kernel-source/tmp/current$ qcat
        847a1d6796c7 e1000: Do not overestimate descriptor counts in Tx pre-check (v4.6-rc3)
        a4605fef7132 e1000: Double Tx descriptors needed check for 82544 (v4.6-rc3)
        1f2f83f83848 e1000: call ndo_stop() instead of dev_close() when running offline selftest (v4.7-rc1)
        91c527a55664 ethernet/intel: use core min/max MTU checking (v4.10-rc1)
        311191297125 e1000: use disable_hardirq() for e1000_netpoll() (v4.10-rc1)

Start backporting:
kernel-source/tmp/current$ qdoit -j4 drivers/net/ethernet/intel/e1000/

For each commit in the list, this command will
* go to the appropriate location in the series using `qgoto` which calls
  `quilt push/pop`
* check that the commit is not already present somewhere in the series using
  `qdupcheck`
* import the commit using `qcp` which calls `git format-patch` and `quilt
  import`
* add required tags using `clean_header.sh`
* apply the commit using `quilt push`
* build test the result using `qfmake`. This calls make with the options
  specified to `qdoit` plus the .o targets corresponding to the .c files
  changed by the topmost patch.

The process will stop automatically in case of error. At that time the user
must address the situation and then call qdoit again when ready.

To address the situation,
if a commit is already present:
* possibly leave it where it is or move it to the current location, then call
  qskip
* remove the other copy, then call
  qcp <commit>
  and follow as indicated below (q push, qfmake, ./refresh_patch.sh)

if a commit does not apply:
q push -f # or -fm
vi-conflicts # also from git-helpers
qfmake [...]
./refresh_patch.sh

if one or more additional commits are necessary to fix the problem:
qedit

Note that the queue of commits to backport is sorted after invoking qadd or
qedit. Therefore, commits can be added anywhere in the list when using qedit.

if it turns out that the commit should be skipped:
q delete -r
or, if after having done `q push -f`:
q pop -f
q delete -r $(q next)

The following commands can be useful to identify the origin of code lines when
fixing conflicts:
quilt annotate <file>
git gui blame --line=<line> <commit> <file>

+ Example workflow using kernel.git
++ Obtain a patch set
+++ Option 1) Patch files from an external source
When the patches come from vendors and have uncertain content: run a first
pass of clean_patch.sh.

patches$ for file in *; do echo $file; clean_header.sh -r "bnc#790588 FATE#313912" $file; done

Although not mandatory, this step gives an idea of what condition the patch
set is in to begin with. If this step succeeds, we will be able to have nice
tags at the end.

++++ Import the patch set into kernel.git
Import the patch set into kernel.git to make sure that it applies, compiles
and works. The custom SUSE tags (Patch-mainline, ...) will be lost in the
process. Before doing `git am`, run armor_origin.sh which transforms the
"Git-commit" tag into a "(cherry picked from ...)" line.

patches$ for file in *; do echo $file; armor_origin.sh $file; done
kernel$ git am /tmp/patches/cleaned/*

Use `git rebase -i` to add missing commits where they belong or generally fixup
what needs to be.

kernel$ git format-patch -o /tmp/patches/sp3 origin/SLE11-SP3..

+++ Option 2) Commits from a git repository
As an alternative to the previous steps, use this procedure when there is no
patch set that comes from the vendor and it is instead us who are doing the
backport.

++++ Generate the list of commit ids to backport
upstream$ git log --no-merges --topo-order --reverse --pretty=tformat:%H v3.12.6.. -- drivers/net/ethernet/emulex/benet/ > /tmp/output

Optionally, generate a description of the commits to backport.

upstream$ cat /tmp/output | xargs -n1 git log -n1 --oneline > /tmp/list

Optionally, check if commits in the list are referenced in the logs of later
commits which are not in the list themselves. You may wish to review these
later commits and add them to the list.

upstream$ cat /tmp/list | check_missing_fixes.sh

Optionally, check which commits in the list have already been applied to
kernel-source.git. Afterwards, you may wish to regenerate the list of commit
ids with a different starting point; or remove from series.conf the commits
that have already been applied and cherry-pick them again during the backport;
or skip them during the backport.

# note that the path is a pattern, not just a base directory
kernel-source$ cat /tmp/list | refs_in_series.sh "drivers/net/ethernet/emulex/benet/*"

Write to a file the list of patches in series.conf that the new commits will
be mixed in with. These patches must have Git-commit tags.

kernel-source$ vi series.conf # w /tmp/list_series

Generate the reverse patch for kernel.git

kernel-source$ ./scripts/sequence-patch.sh --fast
kernel-source$ mv $(readlink -f tmp/current) tmp/base
# edit series.conf and remove the patches that were written to list_series and
# possibly later patches that depend on them.
kernel-source$ ./scripts/sequence-patch.sh --fast
kernel-source$ diff -Nurp --exclude series --exclude .pc --exclude patches --exclude .config --exclude Module.supported tmp/base tmp/current > /tmp/patch
kernel-source$ rm -rf tmp/base

++++ Cherry-pick each desired commit to kernel.git
kernel$ git apply -p2 < /tmp/patch
kernel$ git add -A
kernel$ git commit -m "revert-restore"
kernel$ git log -n1 --oneline # will be needed later
ccdc24086d54 revert-restore

kernel$ . ~/programming/suse/ksapply/backport-mode.sh
# note that the pattern is quoted
kernel$ bpset -s -p ../kernel-source/ -a /tmp/list_series -c /tmp/list2 "drivers/net/ethernet/emulex/benet/*"

# examine the next commit using the following commands
bpref
bpnext
bpstat

# apply the next commit completely
bpcherry-pick-all
bpcp

# apply a subset of the next commit
# the changes under the path specified to bpset are included, more can
# optionally be specified
bpcherry-pick-include <path>
bpcpi

After applying a commit, you may have to fix conflicts manually. Moreover,
it's a good thing to check that the result builds. Sometimes the driver commit
depends on a core change. In that case, the core change can be cherry-picked
and moved just before the current commit using git rebase -i.

# alternatively, instead of applying the next commit, skip it
bpskip

There is a command to automate the above steps. It applies the next commit and
checks that the result builds, for all remaining commits that were fed to
`bpset`, one commit at a time. The command stops when there are problems.
After manually fixing the problems, the command can be run again to resume
where it stopped. To speed things up, `make` is called with a target
directory, which is the argument.
bpdoit drivers/net/ethernet/emulex/benet/

kernel$ git format-patch -o /tmp/patches/sp3 ccdc24086d54

++ Import the patch set into kernel-source.git
Temporarily remove the patches that will be replaced.

kernel-source$ git diff series.conf | grep "^-[[:space:]]" | awk '{print $2}' | xargs rm

Check series.conf to find where the patch set will go and note the last patch
before that (ex:
"patches.drivers/IB-0004-mlx4-Configure-extended-active-speeds.patch") and the
next patch after that (ex: "patches.drivers/iwlwifi-sp1-compatible-options").

kernel-source$ ./scripts/sequence-patch.sh patches.drivers/IB-0004-mlx4-Configure-extended-active-speeds.patch
kernel-source$ cd tmp/current
kernel-source/tmp/current$ quilt import /tmp/patches/sp3/*
kernel-source/tmp/current$ while ! ( quilt next | grep -q iwlwifi-sp1-compatible-options) &&
	ksapply.sh -R "bnc#790588 FATE#313912" -s suse.com patches.drivers/; do true; done
kernel-source/tmp/current$ cd ../../

Copy the new entries to their desired location in series.conf

kernel-source/tmp/current$ vi -p series.conf tmp/current/series

kernel-source$ git add -A
kernel-source$ scripts/log
