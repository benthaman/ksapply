backport-mode.sh
	Contains a set of shell functions to assist in generating a patch
	series from upstream commits.
	Useful when porting a list of commits from upstream to our kernel.
armor_origin.sh
	Transform a "Git-commit" tag into a "(cherry picked from ...)" line.
	Useful before importing patches into kernel.git.
clean_header.sh
	Filter a patch file such that it is properly formatted per SUSE rules.
	Useful before importing patches.
ksapply.sh
	Apply the next patch in the quilt queue while cleaning and renaming it.
	Useful when importing patches into kernel-source.git.
rename_patch.sh
	Move a patch file such that its new name is similar to what git
	format-patch would have picked.
	Useful when importing patches from a maildir.
refs_in_series.sh
	Check if a commit is already part of a branch in kernel-source.git
	Useful to check if a list of commits have already been backported to
	our kernel.

+ Example workflow
++ Clean the patch set
When the patches come from vendors and have uncertain content: run a first
pass of clean_patch.sh.

patches$ for file in *; do echo $file; clean_header.sh -r "bnc#790588 FATE#313912" $file; done

Although not mandatory, this step gives an idea of what condition the patch
set is in to begin with. If this step succeeds, we will be able to have nice
tags at the end.

++ Import the patch set into kernel.git
Import the patch set into kernel.git to make sure that it applies, compiles
and works. The custom SUSE tags (Patch-mainline, ...) will be lost in the
process. Before doing `git am`, run armor_origin.sh which transforms the
"Git-commit" tag into a "(cherry picked from ...)" line.

patches$ for file in *; do echo $file; armor_origin.sh $file; done
kernel$ git am /tmp/patches/cleaned/*

Use `git rebase -i` to add missing commits where they belong or generally fixup
what needs to be.

kernel$ git format-patch -o /tmp/patches/sp3 origin/SLE11-SP3..

++ Create the patch set
As an alternative to the previous steps, use this procedure when there is no
patch set that comes from the vendor and it is instead us who are doing the
backport.

+++ Generate the list of commit ids to backport
upstream$ git log --no-merges --topo-order --reverse --pretty=tformat:%H v3.12.6.. -- drivers/net/ethernet/emulex/benet/ > /tmp/output

Optionally, generate a description of the commits to backport.

upstream$ cat /tmp/output | xargs -n1 git log -n1 --oneline > /tmp/list

Optionally, check which commits in the list have already been applied to
kernel-source.git. Afterwards, you may wish to regenerate the list of commit
ids with a different starting point; or remove from series.conf the commits
that have already been applied and cherry-pick them again during the backport;
or skip them during the backport.

# note that the path is a pattern, not just a base directory
kernel-source$ cat /tmp/list | ~/programming/suse/ksapply/refs_in_series.sh "drivers/net/ethernet/emulex/benet/*"

+++ Cherry-pick each desired commit to kernel.git
kernel$ . ~/programming/suse/ksapply/backport-mode.sh
# note that the pattern is quoted
kernel$ bpset "drivers/net/ethernet/emulex/benet/*" < /tmp/output

# examine the next commit using the following commands
bpref
bpnext
bpstat

# apply the next commit completely
bpcherry-pick-all
bpcp

# apply a subset of the next commit
# the changes under the path specified to bpset are included, more can
# optionally be specified
bpcherry-pick-include <path>
bpcpi

After applying a commit, you may have to fix conflicts manually. Moreover,
it's a good thing to check that the result builds. Sometimes the driver commit
depends on a core change. In that case, the core change can be cherry-picked
and moved just before the current commit using git rebase -i.

# alternatively, instead of applying the next commit, skip it
bpskip

There is a command to automate the above steps. It applies the next commit and
checks that the result builds, for all remaining commits that were fed to
`bpset`, one commit at a time. The command stops when there are problems.
After manually fixing the problems, the command can be run again to resume
where it stopped. To speed things up, `make` is called with a target
directory, which is the argument.
bpdoit drivers/net/ethernet/emulex/benet/

kernel$ git format-patch -o /tmp/patches/sp3 origin/SLE12

++ Import the patch set into kernel-source.git
Check series.conf to find where the patch set will go and note the last patch
before that (ex:
"patches.drivers/IB-0004-mlx4-Configure-extended-active-speeds.patch") and the
next patch after that (ex: "patches.drivers/iwlwifi-sp1-compatible-options").

kernel-source$ ./scripts/sequence-patch.sh patches.drivers/IB-0004-mlx4-Configure-extended-active-speeds.patch
kernel-source$ cd tmp/current
kernel-source/tmp/current$ quilt import /tmp/patches/sp3/*
kernel-source/tmp/current$ while ! ( quilt next | grep -q iwlwifi-sp1-compatible-options) &&
	ksapply.sh -r "bnc#790588 FATE#313912" -p tg3 -n patches.drivers/; do true; done
kernel-source/tmp/current$ cd ../../
kernel-source$ git status
[...]

Add the patches to series.conf. If some patches depend on patches that change
core networking components, move them from patches.drivers to patches.fixes.

kernel-source$ git add -A
kernel-source$ scripts/log
